/*
	
Write a function that add two numbers A and B. You should not use + or any arithmetic operators.

Have you met this question in a real interview? Yes
Example
Given a=1 and b=2 return 3

Note
There is no need to read data from standard input stream. Both parameters are given in function aplusb, you job is to calculate the sum and return it.

Challenge
Of course you can just return a + b to get accepted. But Can you challenge not do it like that?

Clarification
Are a and b both 32-bit integers?

Yes.
Can I use bit operation?

Sure you can.
	
*/

#include "../commonHeader.h"

//doesn't work
int aplusb(int a, int b) 
{
	int n = 30;
	int carry = false;
	int result = 0;
	for(int i = 0; i < n; i++)
	{
		int bit1 = 0x01 & (a >> i);
		int bit2 = 0x01 & (b >> i);
		if(carry)
		{
			if(bit1 == 1 && bit2 == 1)
			{
				result |= 0x1;
			}
			else if(bit1 == 0 && bit2 == 0)
			{
				result |= 0x1;
				carry = false;
			}
		}
		else
		{
			if(bit1 == 1 && bit2 == 1)
			{
				carry = true;
			}
			else if(bit1 == 1 || bit2 == 1)
			{
				result |= 0x01;
			}
		}
		
		result <<= 1;
	}
	
	//reserve the integer
	int newResult = 0;
	for(int i = 0; i < n; i++)
	{
		newResult |= (result  & 0x01);
		newResult <<= 1;
		result >>= 1;
	}
	newResult >>= 1;
	return newResult;
}

//http://simpleandstupid.com/2014/12/21/a-b-problem-lintcode-%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/
int aplusbI(int a, int b) 
{	
	//For a + b in any base, we can treat the plus as two part: 1. a + b without carry; 2. the carry generated by a +b. The a+b then equals to part 1 plus part 2. If part1+part2 generates more carry, we can then repeat this procedure, until there is no carry.
	while(b != 0)
	{
	    int carry = a & b;
	    a = a ^ b;
	    b = carry << 1;
	}
	return a;
}

int main()
{
	int a = 1000000000;
	cout << a << INT_MAX << endl;
	int b = 1000000000;
	cout << aplusb(a,b) << endl;
}